<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>N2 Storage Client</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
    <style>
        .glass {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .progress-bar {
            transition: width 0.2s ease-out;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-900 to-slate-800 min-h-screen text-slate-800 font-sans p-4 sm:p-8">

    <div class="max-w-6xl mx-auto space-y-6">
        
        <!-- Header & Auth Config -->
        <div class="glass rounded-xl p-6 shadow-xl relative">
            
            <div class="flex justify-between items-start mb-4">
                <h1 class="text-3xl font-bold text-slate-800 flex items-center gap-2">
                    <i class="fa-solid fa-server text-blue-600"></i> N2 Storage Client
                    <span class="text-xs bg-blue-100 text-blue-800 px-2 py-0.5 rounded-full font-mono ml-2">RESUMABLE MODE</span>
                </h1>
                <button onclick="logout()" class="text-xs text-red-500 hover:text-red-700 font-bold border border-red-200 px-3 py-1 rounded">
                    LOGOUT
                </button>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <input type="text" id="apiBaseUrl" placeholder="API URL" value="https://api.litiaina.com" class="border p-2 rounded w-full text-sm bg-slate-50">
                <input type="text" id="authToken" placeholder="Bearer Token (Auto-filled)" class="border p-2 rounded w-full text-sm bg-yellow-50 font-mono text-xs">
                <input type="text" id="uid" placeholder="User UID (Auto-filled)" class="border p-2 rounded w-full text-sm bg-yellow-50 font-mono text-xs">
            </div>
            
            <div class="mt-4 flex gap-2">
                <input type="text" id="fragmentName" placeholder="Fragment Name (e.g. public)" value="public" class="border p-2 rounded w-full text-sm max-w-xs">
                <button onclick="refreshFileList()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded text-sm transition font-medium shadow-md">
                    <i class="fa-solid fa-rotate"></i> Load Files
                </button>
            </div>

            <div id="userInfo" class="absolute top-6 right-20 text-xs text-right hidden md:block">
                <p class="font-bold text-slate-700" id="userNameDisplay">Guest</p>
                <p class="text-slate-500" id="userEmailDisplay">Not connected</p>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            
            <!-- Uploader/Downloader Queue Section -->
            <div class="glass rounded-xl p-6 shadow-xl h-fit">
                <h2 class="text-xl font-bold mb-4 flex items-center gap-2">
                    <i class="fa-solid fa-cloud-arrow-up text-blue-600"></i> Active Transfers
                </h2>
                
                <div class="border-2 border-dashed border-slate-300 rounded-xl p-8 text-center hover:bg-slate-50 transition cursor-pointer relative mb-4" id="dropZone">
                    <input type="file" id="fileInput" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer" multiple>
                    <div class="space-y-2 pointer-events-none">
                        <i class="fa-solid fa-file-arrow-up text-4xl text-slate-400"></i>
                        <p class="text-slate-500 font-medium">Drag files here to Upload</p>
                    </div>
                </div>

                <div id="transferQueue" class="mt-6 space-y-4 max-h-[400px] overflow-y-auto">
                    <!-- Transfer items will appear here -->
                </div>
            </div>

            <!-- File Browser Section -->
            <div class="glass rounded-xl p-6 shadow-xl">
                <h2 class="text-xl font-bold mb-4 flex items-center gap-2">
                    <i class="fa-solid fa-folder-open text-blue-600"></i> Files
                    <span id="fileCount" class="text-xs bg-slate-200 px-2 py-1 rounded-full text-slate-600 ml-auto">0</span>
                </h2>
                
                <div class="overflow-y-auto max-h-[600px] pr-2">
                    <table class="w-full text-left border-collapse">
                        <thead>
                            <tr class="border-b border-slate-200 text-slate-500 text-sm">
                                <th class="py-2 font-medium">Name</th>
                                <th class="py-2 font-medium w-24">Size</th>
                                <th class="py-2 font-medium w-40 text-right">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="fileListBody" class="text-sm">
                            <tr>
                                <td colspan="3" class="py-8 text-center text-slate-400 italic">
                                    No files loaded. Check config and click Load.
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

        </div>
    </div>

    <!-- Notification Toast -->
    <div id="toast" class="fixed bottom-4 right-4 bg-slate-800 text-white px-6 py-3 rounded-lg shadow-xl transform translate-y-24 transition duration-300 flex items-center gap-3 z-50">
        <i id="toastIcon" class="fa-solid fa-info-circle"></i>
        <span id="toastMsg">Notification</span>
    </div>

    <script data-cfasync="false">
        // --- Tuning Parameters ---
        const CHUNK_SIZE = 14 * 1024 * 1024; // 14MB chunks
        const MAX_CONCURRENT_TRANSFERS = 24; // Parallel streams per file

        // --- Helpers ---
        const getEl = (id) => document.getElementById(id);
        const formatSize = (bytes) => {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        };
        const encodePath = (path) => path.split('/').map(encodeURIComponent).join('/');

        const showToast = (msg, type = 'info') => {
            const toast = getEl('toast');
            const icon = getEl('toastIcon');
            getEl('toastMsg').innerText = msg;
            
            toast.className = `fixed bottom-4 right-4 px-6 py-3 rounded-lg shadow-xl transform transition duration-300 flex items-center gap-3 z-50 text-white ${
                type === 'error' ? 'bg-red-600' : type === 'success' ? 'bg-green-600' : 'bg-slate-800'
            }`;
            
            icon.className = `fa-solid ${
                type === 'error' ? 'fa-triangle-exclamation' : type === 'success' ? 'fa-check-circle' : 'fa-info-circle'
            }`;

            toast.classList.remove('translate-y-24');
            setTimeout(() => toast.classList.add('translate-y-24'), 4000);
        };

        const createQueueItem = (id, filename, type = 'upload') => {
            const queueDiv = getEl('transferQueue');
            const itemDiv = document.createElement('div');
            itemDiv.id = `transfer-${id}`;
            itemDiv.className = "bg-white p-3 rounded-lg border border-slate-200 shadow-sm";
            const icon = type === 'upload' ? 'fa-arrow-up text-blue-500' : 'fa-arrow-down text-green-500';
            
            itemDiv.innerHTML = `
                <div class="flex justify-between mb-1">
                    <div class="flex items-center gap-2 w-3/4">
                        <i class="fa-solid ${icon} text-xs"></i>
                        <span class="text-sm font-medium text-slate-700 truncate">${filename}</span>
                    </div>
                    <span class="text-xs text-slate-500" id="status-${id}">0%</span>
                </div>
                <div class="w-full bg-slate-100 rounded-full h-2">
                    <div class="bg-blue-500 h-2 rounded-full progress-bar" style="width: 0%" id="progress-${id}"></div>
                </div>
            `;
            queueDiv.prepend(itemDiv);
        };

        const updateQueueItem = (id, pct, statusText = null) => {
            const safePct = Math.min(pct, 100);
            getEl(`progress-${id}`).style.width = `${safePct}%`;
            getEl(`status-${id}`).innerText = statusText ? statusText : `${Math.round(safePct)}%`;
            
            if (safePct >= 100) {
                getEl(`progress-${id}`).className = "bg-green-500 h-2 rounded-full";
            }
        };

        const errorQueueItem = (id) => {
            getEl(`status-${id}`).innerHTML = `<span class="text-red-600 font-bold">Error</span>`;
            getEl(`progress-${id}`).className = "bg-red-500 h-2 rounded-full";
        };

        // --- Auth & Init ---
        function initSession() {
            const storedToken = localStorage.getItem("current-token");
            const storedUid = localStorage.getItem("current-account-uid");
            const storedName = localStorage.getItem("current-account-name");
            const storedEmail = localStorage.getItem("current-account-email");

            if (storedToken) getEl('authToken').value = storedToken;
            if (storedUid) getEl('uid').value = storedUid;
            if (storedName) {
                getEl('userNameDisplay').innerText = storedName;
                getEl('userEmailDisplay').innerText = storedEmail || "";
            }

            if (!storedToken) {
                showToast("Not logged in. Please use login.html first.", "error");
            } else {
                showToast(`Ready. Connected as ${storedName || 'User'}`, "success");
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initSession);
        } else {
            initSession();
        }

        function logout() {
            localStorage.removeItem("current-token");
            localStorage.removeItem("current-account-uid");
            localStorage.removeItem("remember-me");
            window.location.href = "login.html";
        }

        const getHeaders = () => {
            let token = getEl('authToken').value;
            let uid = getEl('uid').value;
            
            if (!token) token = localStorage.getItem("current-token");
            if (!uid) uid = localStorage.getItem("current-account-uid");

            if (!token || !uid) {
                showToast("Missing credentials. Please login.", "error");
                throw new Error("Missing credentials");
            }

            const cleanToken = token.startsWith('Bearer ') ? token.replace('Bearer ', '') : token;
            return {
                'Authorization': `Bearer ${cleanToken}`, 
                'uid': uid,
                'Content-Type': 'application/json'
            };
        };

        // --- File Listing ---
        async function refreshFileList() {
            const baseUrl = getEl('apiBaseUrl').value.replace(/\/$/, "");
            const fragment = getEl('fragmentName').value;
            
            try {
                const response = await fetch(`${baseUrl}/v4/fragment/object/metadata/${encodeURIComponent(fragment)}`, {
                    method: 'GET',
                    headers: getHeaders()
                });

                if (!response.ok) throw new Error('Failed to fetch list.');
                
                const files = await response.json();
                renderFiles(files);
                showToast(`Loaded ${files.length} files`, 'success');
            } catch (err) {
                console.error(err);
                showToast(err.message, 'error');
            }
        }

        function renderFiles(files) {
            const tbody = getEl('fileListBody');
            getEl('fileCount').innerText = files.length;
            tbody.innerHTML = '';

            if (files.length === 0) {
                tbody.innerHTML = `<tr><td colspan="3" class="py-8 text-center text-slate-400 italic">No files found.</td></tr>`;
                return;
            }

            files.forEach(file => {
                const tr = document.createElement('tr');
                tr.className = "border-b border-slate-100 hover:bg-slate-50 transition";
                tr.innerHTML = `
                    <td class="py-3 pr-2">
                        <div class="flex items-center gap-3">
                            <div class="bg-blue-100 text-blue-600 w-8 h-8 rounded flex items-center justify-center">
                                <i class="fa-regular fa-file"></i>
                            </div>
                            <div class="font-medium text-slate-700 break-all">${file.object_key}</div>
                        </div>
                    </td>
                    <td class="py-3 text-slate-500 font-mono text-xs whitespace-nowrap">${formatSize(file.total_size_bytes)}</td>
                    <td class="py-3 text-right">
                        <div class="flex justify-end gap-1">
                            <button onclick="viewFile('${file.fragment}', '${file.object_key}')" class="text-slate-400 hover:text-green-600 p-2 rounded hover:bg-green-50 transition" title="View (Stream)">
                                <i class="fa-solid fa-eye"></i>
                            </button>
                            <button onclick="downloadFileNative('${file.fragment}', '${file.object_key}')" class="text-slate-400 hover:text-blue-600 p-2 rounded hover:bg-blue-50 transition" title="Download">
                                <i class="fa-solid fa-download"></i>
                            </button>
                            <button onclick="renameFile('${file.fragment}', '${file.object_key}')" class="text-slate-400 hover:text-orange-500 p-2 rounded hover:bg-orange-50 transition" title="Rename">
                                <i class="fa-solid fa-pen"></i>
                            </button>
                            <button onclick="downloadFileTurboStream('${file.fragment}', '${file.object_key}', ${file.total_size_bytes})" class="text-slate-300 hover:text-purple-600 p-2 rounded hover:bg-purple-50 transition opacity-50 hover:opacity-100" title="Parallel Stream Download (Experimental)">
                                <i class="fa-solid fa-bolt"></i>
                            </button>
                            <button onclick="deleteFile('${file.fragment}', '${file.object_key}')" class="text-slate-400 hover:text-red-600 p-2 rounded hover:bg-red-50 transition" title="Delete">
                                <i class="fa-solid fa-trash"></i>
                            </button>
                        </div>
                    </td>
                `;
                tbody.appendChild(tr);
            });
        }

        // --- Actions ---
        
        async function renameFile(fragment, currentKey) {
            const newKey = prompt("Enter new filename (can include folders like 'videos/file.mp4'):", currentKey);
            if (!newKey || newKey === currentKey) return;

            const baseUrl = getEl('apiBaseUrl').value.replace(/\/$/, "");
            
            try {
                const response = await fetch(`${baseUrl}/v4/fragment/object/rename`, {
                    method: 'PATCH',
                    headers: getHeaders(),
                    body: JSON.stringify({
                        source_fragment: fragment,
                        source_key: currentKey,
                        destination_fragment: fragment,
                        destination_key: newKey
                    })
                });

                if (!response.ok) throw new Error("Rename failed");
                showToast("File renamed", "success");
                refreshFileList();
            } catch (e) {
                showToast(e.message, 'error');
            }
        }

        async function viewFile(fragment, key) {
            const baseUrl = getEl('apiBaseUrl').value.replace(/\/$/, "");
            try {
                showToast("Generating view link...", "info");
                const headers = getHeaders();
                const response = await fetch(`${baseUrl}/v4/fragment/object/share`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify({
                        fragment: fragment,
                        object_key: key,
                        expires_in: 3600,
                        disposition: 'stream' 
                    })
                });

                if (!response.ok) throw new Error("Failed to generate link.");
                const data = await response.json();
                
                const finalUrl = new URL(data.url);
                const apiObj = new URL(baseUrl);
                finalUrl.protocol = apiObj.protocol;
                finalUrl.host = apiObj.host;

                window.open(finalUrl.toString(), '_blank');

            } catch (e) {
                showToast(e.message, 'error');
            }
        }

        async function deleteFile(fragment, key) {
            if(!confirm(`Delete ${key}?`)) return;
            const baseUrl = getEl('apiBaseUrl').value.replace(/\/$/, "");

            try {
                // Encode everything for the URL path
                const response = await fetch(`${baseUrl}/v4/fragment/object/delete/${encodeURIComponent(fragment)}/${encodePath(key)}`, {
                    method: 'DELETE',
                    headers: getHeaders()
                });
                if (!response.ok) throw new Error("Delete failed");
                showToast("File deleted", "success");
                refreshFileList();
            } catch (e) {
                showToast(e.message, 'error');
            }
        }

        async function downloadFileNative(fragment, key) {
            const baseUrl = getEl('apiBaseUrl').value.replace(/\/$/, "");
            try {
                showToast("Generating secure link...", "info");
                const headers = getHeaders();
                const response = await fetch(`${baseUrl}/v4/fragment/object/share`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify({
                        fragment: fragment,
                        object_key: key,
                        expires_in: 3600,
                        disposition: 'download'
                    })
                });

                if (!response.ok) throw new Error("Failed to sign download link.");
                const data = await response.json();

                const finalUrl = new URL(data.url);
                const apiObj = new URL(baseUrl);
                finalUrl.protocol = apiObj.protocol;
                finalUrl.host = apiObj.host;

                const downloadLink = document.createElement('a');
                downloadLink.href = finalUrl.toString();
                document.body.appendChild(downloadLink);
                downloadLink.click();
                downloadLink.remove();
                showToast("Download started", "success");
            } catch (e) {
                showToast(e.message, 'error');
            }
        }

        // 2. Turbo Stream Download (Experimental)
        // Uses File System Access API to stream chunks directly to disk
        async function downloadFileTurboStream(fragment, key, totalSize) {
            // Check browser support
            if (!window.showSaveFilePicker) {
                alert("Your browser doesn't support the File System Access API needed for Turbo Stream. Falling back to native download.");
                return downloadFileNative(fragment, key);
            }

            const baseUrl = getEl('apiBaseUrl').value.replace(/\/$/, "");
            const transferId = Math.random().toString(36).substring(7);
            createQueueItem(transferId, key, 'download');
            
            let fileHandle;
            let writable;

            try {
                // 1. Get File Handle from User
                fileHandle = await window.showSaveFilePicker({
                    suggestedName: key.split('/').pop(),
                });
                writable = await fileHandle.createWritable();

                const headers = getHeaders();
                const totalChunks = Math.ceil(totalSize / CHUNK_SIZE);
                let downloadedBytes = 0;
                
                // We must process chunks somewhat sequentially for the file writer, 
                // OR we can write out of order if the API supports seek/writeAt.
                // Creating a simplified parallel fetcher that writes in order is safer.
                
                // Parallel Fetching Buffer
                const concurrency = 3; 
                let nextChunkToWrite = 0;
                const chunkBuffer = new Map(); // Index -> ArrayBuffer

                const fetchChunk = async (i) => {
                    const start = i * CHUNK_SIZE;
                    const end = Math.min(start + CHUNK_SIZE - 1, totalSize - 1);
                    
                    const chunkUrl = new URL(`${baseUrl}/v4/fragment/object/download/${encodeURIComponent(fragment)}`);
                    chunkUrl.searchParams.append('object_key', key);
                    
                    const chunkHeaders = { 
                        'Authorization': headers['Authorization'],
                        'uid': headers['uid'],
                        'Range': `bytes=${start}-${end}`
                    };

                    let retries = 3;
                    while(retries > 0) {
                        try {
                            const res = await fetch(chunkUrl, { headers: chunkHeaders });
                            if(!res.ok && res.status !== 206) throw new Error(`Status ${res.status}`);
                            return await res.arrayBuffer();
                        } catch(e) {
                            retries--;
                            if(retries === 0) throw e;
                            await new Promise(r => setTimeout(r, 1000));
                        }
                    }
                };

                const writeLoop = async () => {
                    while (nextChunkToWrite < totalChunks) {
                        if (chunkBuffer.has(nextChunkToWrite)) {
                            const data = chunkBuffer.get(nextChunkToWrite);
                            chunkBuffer.delete(nextChunkToWrite);
                            await writable.write(data);
                            downloadedBytes += data.byteLength;
                            nextChunkToWrite++;
                            updateQueueItem(transferId, (downloadedBytes / totalSize) * 100);
                        } else {
                            await new Promise(r => setTimeout(r, 50)); // Wait for data
                        }
                    }
                };

                // Start Writing Loop
                const writerPromise = writeLoop();

                // Start Fetching Loop
                const fetchIndices = Array.from({length: totalChunks}, (_, i) => i);
                const executing = [];

                for (const i of fetchIndices) {
                    // Backpressure: Don't fetch too far ahead of writer to save RAM
                    while (i > nextChunkToWrite + concurrency + 2) {
                        await new Promise(r => setTimeout(r, 100));
                    }

                    const p = fetchChunk(i).then((data) => {
                        chunkBuffer.set(i, data);
                        executing.splice(executing.indexOf(p), 1);
                    });
                    executing.push(p);
                    if (executing.length >= concurrency) {
                        await Promise.race(executing);
                    }
                }
                
                await Promise.all(executing);
                await writerPromise; // Ensure writing is done
                await writable.close();

                updateQueueItem(transferId, 100, "Completed");
                showToast("Stream Download Complete", "success");

            } catch (e) {
                console.error(e);
                if (writable) await writable.close().catch(() => {}); 
                errorQueueItem(transferId);
                showToast(`Download failed: ${e.message}`, "error");
            }
        }

        // --- RESUMABLE UPLOAD ---
        getEl('fileInput').addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            if(files.length === 0) return;
            for (const file of files) {
                await uploadFile(file);
            }
            e.target.value = '';
        });

        async function uploadFile(file) {
            const baseUrl = getEl('apiBaseUrl').value.replace(/\/$/, "");
            const fragment = getEl('fragmentName').value;
            const objectKey = file.name; 
            
            const uploadId = Math.random().toString(36).substring(7);
            createQueueItem(uploadId, objectKey, 'upload');

            try {
                const headers = getHeaders();
                const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
                let version_id, session_id;
                let existingParts = new Set();

                // 1. CHECK FOR RESUMABLE SESSION
                const resumeKey = `upload_session_${fragment}_${objectKey}_${file.size}_${file.lastModified}`;
                const storedSession = localStorage.getItem(resumeKey);

                if (storedSession) {
                    const sessionData = JSON.parse(storedSession);
                    updateQueueItem(uploadId, 0, "Checking resume status...");
                    
                    try {
                        const safeKey = encodePath(objectKey);
                        const safeFragment = encodeURIComponent(fragment);
                        const statusUrl = new URL(`${baseUrl}/v4/fragment/object/upload/status/${safeFragment}/${sessionData.version_id}`);
                        statusUrl.searchParams.append('object_key', objectKey);

                        const statusRes = await fetch(statusUrl, { headers });
                        if (statusRes.ok) {
                            const statusData = await statusRes.json();
                            version_id = sessionData.version_id;
                            session_id = sessionData.session_id;
                            existingParts = new Set(statusData.uploaded_parts);
                            showToast(`Resuming upload (${existingParts.size}/${totalChunks} chunks done)`, "info");
                        } else {
                            localStorage.removeItem(resumeKey);
                        }
                    } catch (e) {
                        console.warn("Failed to check status, starting over", e);
                        localStorage.removeItem(resumeKey);
                    }
                }

                // 2. INITIATE (If not resumed)
                if (!version_id) {
                    updateQueueItem(uploadId, 0, "Initiating...");
                    const safeKey = encodePath(objectKey);
                    const safeFragment = encodeURIComponent(fragment);
                    
                    const initRes = await fetch(`${baseUrl}/v4/fragment/object/upload/init/${safeFragment}/${safeKey}`, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify({
                            content_type: file.type || 'application/octet-stream',
                            total_size_bytes: file.size,
                            total_chunks: totalChunks
                        })
                    });

                    if (!initRes.ok) throw new Error("Init failed");
                    const data = await initRes.json();
                    version_id = data.version_id;
                    session_id = data.session_id;

                    localStorage.setItem(resumeKey, JSON.stringify({ version_id, session_id }));
                }

                // 3. PARALLEL CHUNK UPLOAD
                let uploadedBytes = 0;
                // Calculate progress start
                for(let i=0; i<totalChunks; i++) {
                    if(existingParts.has(i)) {
                        const start = i * CHUNK_SIZE;
                        const end = Math.min(start + CHUNK_SIZE, file.size);
                        uploadedBytes += (end - start);
                    }
                }

                const chunkIndices = Array.from({ length: totalChunks }, (_, i) => i)
                                          .filter(i => !existingParts.has(i));

                if(chunkIndices.length === 0) {
                    updateQueueItem(uploadId, 99, "All chunks present...");
                }

                const safeFragment = encodeURIComponent(fragment);

                const uploadSingleChunk = async (i) => {
                    const start = i * CHUNK_SIZE;
                    const end = Math.min(start + CHUNK_SIZE, file.size);
                    const chunk = file.slice(start, end);

                    const chunkUrl = new URL(`${baseUrl}/v4/fragment/object/upload/chunk/${safeFragment}/${version_id}/${i}`);
                    chunkUrl.searchParams.append('object_key', objectKey);

                    const chunkHeaders = { ...headers, 'Content-Type': 'application/octet-stream' };

                    let retries = 3;
                    while (retries > 0) {
                        try {
                            const res = await fetch(chunkUrl, {
                                method: 'PUT',
                                headers: chunkHeaders,
                                body: chunk 
                            });
                            if (!res.ok) throw new Error(`Status ${res.status}`);
                            break; 
                        } catch (err) {
                            retries--;
                            if (retries === 0) throw err;
                            await new Promise(r => setTimeout(r, 1000)); 
                        }
                    }

                    uploadedBytes += chunk.size;
                    updateQueueItem(uploadId, (uploadedBytes / file.size) * 99);
                };

                const runPool = async () => {
                    const executing = [];
                    for (const i of chunkIndices) {
                        const p = uploadSingleChunk(i).then(() => {
                            executing.splice(executing.indexOf(p), 1);
                        });
                        executing.push(p);
                        if (executing.length >= MAX_CONCURRENT_TRANSFERS) {
                            await Promise.race(executing);
                        }
                    }
                    await Promise.all(executing);
                };

                await runPool();

                // 4. FINALIZE
                updateQueueItem(uploadId, 99, "Finalizing...");
                const finalizeUrl = new URL(`${baseUrl}/v4/fragment/object/upload/finalize/${safeFragment}/${version_id}/${session_id}`);
                finalizeUrl.searchParams.append('object_key', objectKey);

                const finalizeRes = await fetch(finalizeUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify({
                        content_type: file.type,
                        total_size_bytes: file.size,
                        total_chunks: totalChunks
                    })
                });

                if (!finalizeRes.ok) throw new Error("Finalize failed");

                localStorage.removeItem(resumeKey);

                updateQueueItem(uploadId, 100, "Completed");
                showToast("Upload complete!", "success");
                refreshFileList(); 

            } catch (err) {
                console.error(err);
                errorQueueItem(uploadId);
                showToast(`Upload failed: ${err.message}`, "error");
            }
        }
    </script>
</body>
</html>